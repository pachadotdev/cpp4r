---
title: "01 - Motivations for cpp4r"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{01 - Motivations for cpp4r}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor:
  markdown:
    wrap: sentence
bibliography: ["references.bib"]
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Motivation and significance

The R programming language has maintained a long-standing tradition of interfacing with compiled languages, dating back
to the original S implementation in the late 1970s, which served primarily as a wrapper around FORTRAN routines
[@chambers06]. This integration remains relevant today, as R code sometimes lacks the performance needed for
computationally intensive tasks. Even after optimizing R code through vectorization and avoiding unnecessary object
copying, bottlenecks may persist that require compiled language solutions.

C++ offers particular advantages for addressing common R performance bottlenecks, including:

- Loops that cannot be easily vectorized due to dependencies between iterations
- Recursive functions or problems requiring many function calls
- Data structures and algorithms not natively available in R (e.g., R does not let the end-user use pointers and
  pass-by-reference semantics)
- Problems requiring fine-tuning memory management

cpp4r is an R package that provides C++11 bindings to R, enabling the use of C++ code in R packages. It is a fork of the
cpp11 package [@cpp1125] aiming to provide additional features and improvements while maintaining compatibility with the
original cpp11 API.

The landscape of C++ bindings for R has evolved significantly over the past two decades. The cxx package, released in
2000, provided an early prototype of C++ bindings [@hornik01]. Rcpp, first published to CRAN in 2008, became the
mainstream solution with over 2,000 reverse dependencies by 2020 [@eddelbuettel11].

cpp11 was released in 2023 as a complete reimplementation of C++ bindings to R, with different design trade-offs
compared to Rcpp aiming to provide:

- Enforced copy-on-write semantics consistent with R's behavior
- Improved safety when interfacing with R's C API
- Native support for ALTREP objects
- UTF-8 string handling throughout
- Modern C++11 features and idioms
- Simplified implementation compared to Rcpp
- Faster compilation with reduced memory requirements
- Completely header-only design to avoid Application Binary Interface (ABI) compatibility issues

However, cpp11 lacks some Rcpp features that explain its widespread adoption, including:

- Syntactic sugar (e.g., helper functions that allow for a more concise or convenient way to express common
  patterns)
- Modules (e.g., helpers to export C++ functions and/or classes to R more easily)
- Attributes (e.g., decorators to expose C++ functions to R with minimal boilerplate code)

As the benchmarks reveal, cpp4r additional features simplify the development of R packages using C++ code without
sacrificing performance or memory efficiency compared to cpp11 or Rcpp. In terms of speed and memory usage,
users should follow the following decision diagram when choosing between these three C++ bindings for R:

\begin{tikzpicture}[node distance=12mm, >=stealth]
  \tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=6mm,text centered, draw=black, fill=gray!10]
  \tikzstyle{decision} = [diamond, aspect=2, text width=3.6em, text centered, draw=black, fill=blue!10]
  \tikzstyle{arrow} = [thick,->]

  % Nodes
  \node (start) [startstop] {Should you use cpp4r in your package?};
  \node (q1) [decision, below=of start] {Does it currently use cpp11?};
  \node (q2) [decision, right=18mm of q1] {Does it currently use Rcpp?};
  \node (askFeatures) [decision, below=of q1, yshift=-6mm] {Any lacking features (e.g. vendoring)?};
  \node (yes) [startstop, below=of askFeatures, yshift=-4mm, fill=green!10] {Yes: use cpp4r};
  \node (no) [startstop, left=of yes, xshift=-28mm, fill=red!8] {No: keep current binding};

  % Arrows
  \draw [arrow] (start) -- (q1);

  % From q1 yes -> askFeatures
  \draw [arrow] (q1) -- node[midway,left]{Yes} (askFeatures);
  % From q1 no -> check q2
  \draw [arrow] (q1) -- node[midway,above]{No} (q2);

  % From q2 yes -> askFeatures
  \draw [arrow] (q2) -- node[midway,above]{Yes} (askFeatures);
  % From q2 no -> no
  \draw [arrow] (q2) -- node[midway,right]{No} (no);

  % From askFeatures
  \draw [arrow] (askFeatures) -- node[midway,left]{Yes} (yes);
  \draw [arrow] (askFeatures) -- node[midway,right]{No} (no);

\end{tikzpicture}

# Software description

While using cpp11 for my thesis project, I identified several enhancements that could benefit the R community and
improve the library's usability. These enhancements include:

- Support for converting C++ maps to R lists
- Roxygen documentation support directly in C++ code
- Proper handling of matrix attributes
- Support for nullable external pointers
- Immediate availability of values added via `push_back()`
- Bidirectional copy of complex number types
- Flexibility in type conversions
- Various performance optimizations
- Specialized codebase to benefit from newer C++ standards (e.g., if C++20 is available, compiling a package will
  use C++20 features instead of being limited to C++11)

After discussing these proposed enhancements with the cpp11 maintainers, it became clear that the development priorities
and timelines would not accommodate these features in the near term. This led to the creation of cpp4r, a fork of cpp11
that incorporates these additional features while maintaining compatibility with the original cpp11 API. This means that
cpp4r can serve as a drop-in replacement for cpp11 in any case, allowing users to benefit from the enhancements without
significant code changes. The converse, replacing cpp4r with cpp11, requires adjustments due to the additional features
in cpp4r.

cpp4r extends cpp11's container support by enabling seamless conversion between C++ standard library containers and R
objects. This includes support for `std::map` and `std::unordered_map` containers, which are automatically converted to
named R lists.

cpp4r provides roxygen support directly in C++ code, allowing developers to document their C++ functions using familiar
roxygen2 syntax. This integration streamlines the documentation workflow for packages that expose C++ functions to R.

Unlike cpp11, cpp4r properly handles matrix attributes, including `dimnames`, ensuring that matrix operations preserve
metadata when copying data between R and C++.

cpp4r offers more flexible type conversion functions. For example, `as_integers()` and `as_doubles()` accept logical
inputs, providing greater flexibility in handling diverse input types compared to the more restrictive cpp11
implementations.

Several internal optimizations improve performance over cpp11, particularly in vector operations and memory management.
These optimizations maintain the safety guarantees of cpp11 while improving execution speed.

cpp4r provides full bidirectional copying of complex numbers, enabling seamless transfer of complex vectors and matrices
between R and C++ code. In contrast, cpp11 does not support this functionality.

cpp4r maintains cpp11's core design principles while extending functionality:

- Copy-on-Write Semantics: Like cpp11, cpp4r enforces copy-on-write semantics that match R's behavior, preventing
  unexpected modifications to input data.
- Safety First: cpp4r incorporates comprehensive safety mechanisms when interfacing with R's C API, using
  `unwind_protect()` and exception handling to prevent resource leaks.
- Modern C++ Features: The implementation leverages C++11 features including move semantics, type traits, variadic
  templates, and user-defined literals.
- Header-Only Design: As a completely header-only library, cpp4r avoids ABI compatibility issues that can arise with
  libraries containing compiled components.

cpp4r offers vendoring capabilities, which means copying the dependency code directly into your project's source
tree. This approach, borrowed from the Go programming language, includes the dependencies'
headers with the source code [@go24]. This ensures the dependency code remains fixed and stable until explicitly updated. 
Since cpp4r is a header-only library, you can copy all headers by running
`cpp4r::vendor_cpp4r()` when needed.

Vendoring has both advantages and drawbacks. The main advantage is that disruptive changes to the cpp4r project
cannot break your existing code. The drawbacks include slightly larger package size and isolation from
bugfixes and new features until you explicitly update the vendored headers. Most packages should not
vendor the cpp4r dependency, except for projects designed to run in restricted environments where internet access is
limited or unavailable for security reasons (e.g., high-performance computing clusters).

# Software functionalities

cpp4r is designed as a drop-in replacement for cpp11, using identical syntax and API patterns. Existing cpp11 code can
typically be migrated to cpp4r with minimal changes, primarily involving header includes and namespace references.

To use cpp4r, users must first install the package from CRAN or GitHub. The following code shows how to install the
package:

```r
install.packages("cpp4r", repos = "https://cran.rstudio.com")

# or
remotes::install_github("pachadotdev/cpp4r")
```

Once installed, users can use the provided package template function to create a new package that uses C++ code. The
package template includes simple examples and all the necessary files to compile the code and install the new R package.
The following code shows how to create a new package:

```r
cpp4r::pkg_template("~/rstats/mypkg")
```

The package skeleton includes standard practices:

```r
# In DESCRIPTION file
LinkingTo: cpp4r

# In R code
#' @useDynLib mypkg, .registration = TRUE
#' @keywords internal
"_PACKAGE"
```

C++ functions are exposed to R using the attribute syntax and documented with roxygen comments:

```cpp
/* roxygen
@title Square of Each Element in 'x'
@param x Numeric vector
@return Numeric vector
@export
*/
[[cpp4r::register]]
cpp4r::doubles my_square(cpp4r::doubles x) {
  return x * x;
}
```

The equivalent cpp11 code would be:

```cpp
[[cpp11::register]]
cpp11::doubles my_square_cpp(cpp11::doubles x) {
  return x * x;
}
```

```r
#' @title Square of Each Element in 'x'
#' @param x Numeric vector
#' @return Numeric vector
#' @export
my_square <- function(x) {
  my_square_cpp(x)
}
```

# Benchmarks

The goal of these benchmarks is to compare the speed and memory efficiency of cpp11, cpp4r, and Rcpp relative to base R
linear algebra operations. Each of these have Armadillo wrappers: cpp11armadillo, armadillo4r, and RcppArmadillo. Being
Armadillo a heavily optimized linear algebra library, it is expected that the differences in performance between these
packages will be minimal and attributed to the overhead of each C++ binding to R.

The tested armadillo4r 0.6.0 cannot be tested with C++11 as it uses Armadillo "Stochastic Parrot 14.2.2" which requires
C++14 or newer.

The other software versions used are:

1. cpp11armadillo 0.5.4 uses Armadillo "Medium Roast Deluxe 15.2.1"
2. RcppArmadillo 15.0.2-2 uses Armadillo "Medium Roast 15.0.2"

The following benchmarks were adapted from the official [Armadillo](https://arma.sourceforge.net/speed.html)
documentation:

|C++ standard | Function                |Avg. time cpp11armadillo |Avg. time RcppArmadillo |Avg. time cpp4rarmadillo |
|:----------|:--------------------------|:-----------------------|:----------------------|:-----------------------|
|C++11      |Multiple matrix operations |4.03 x 10^-6            |3.43 x 10^-3           |                     |
|C++14      |Multiple matrix operations |4.02 x 10^-6            |3.2 x 10^-3            |3.34 x 10^-3            |
|C++17      |Multiple matrix operations |4.41 x 10^-6            |3.45 x 10^-3           |3.5 x 10^-3             |
|C++20      |Multiple matrix operations |4.75 x 10^-6            |3.54 x 10^-3           |3.59 x 10^-3            |
|C++23      |Multiple matrix operations |5.11 x 10^-6            |3.82 x 10^-3           |3.8 x 10^-3             |
|C++11      |Multiply four matrices     |1.42 x 10^-1            |1.42 x 10^-1           |                     |
|C++14      |Multiply four matrices     |1.46 x 10^-1            |1.3 x 10^-1            |1.26 x 10^-1            |
|C++17      |Multiply four matrices     |1.37 x 10^-1            |1.4 x 10^-1            |1.31 x 10^-1            |
|C++20      |Multiply four matrices     |2.26 x 10^-1            |1.69 x 10^-1           |1.87 x 10^-1            |
|C++23      |Multiply four matrices     |1.38 x 10^-1            |1.38 x 10^-1           |1.41 x 10^-1            |
|C++11      |Submatrix manipulation     |3.42 x 10^-3            |5.9 x 10^-3            |                     |
|C++14      |Submatrix manipulation     |1.72 x 10^-3            |4.06 x 10^-3           |4.44 x 10^-3            |
|C++17      |Submatrix manipulation     |1.73 x 10^-3            |4.25 x 10^-3           |4.35 x 10^-3            |
|C++20      |Submatrix manipulation     |1.92 x 10^-3            |4.68 x 10^-3           |4.65 x 10^-3            |
|C++23      |Submatrix manipulation     |1.92 x 10^-3            |5.2 x 10^-3            |4.97 x 10^-3            |

In relative terms, compared to base R implementation, the results are:

|C++ standard | Function                |Rel. time cpp11armadillo |Rel. time RcppArmadillo |Rel. time cpp4rarmadillo |
|:----------|:--------------------------|:-----------------------|:----------------------|:-----------------------|
|C++11      |Multiple matrix operations |7.21 x 10^-6            |6.14 x 10^-3           |                     |
|C++14      |Multiple matrix operations |7.01 x 10^-6            |5.73 x 10^-3           |3.1 x 10^-3             |
|C++17      |Multiple matrix operations |7.81 x 10^-6            |6.17 x 10^-3           |3.28 x 10^-3            |
|C++20      |Multiple matrix operations |8.41 x 10^-6            |6.32 x 10^-3           |3.41 x 10^-3            |
|C++23      |Multiple matrix operations |8.86 x 10^-6            |6.81 x 10^-3           |3.57 x 10^-3            |
|C++11      |Multiply four matrices     |4.98 x 10^-2            |4.98 x 10^-2           |                     |
|C++14      |Multiply four matrices     |5.1 x 10^-2             |4.54 x 10^-2           |4.41 x 10^-2            |
|C++17      |Multiply four matrices     |4.8 x 10^-2             |4.9 x 10^-2            |4.58 x 10^-2            |
|C++20      |Multiply four matrices     |7.5 x 10^-2             |5.86 x 10^-2           |6.4 x 10^-2             |
|C++23      |Multiply four matrices     |4.76 x 10^-2            |4.81 x 10^-2           |4.9 x 10^-2             |
|C++11      |Submatrix manipulation     |2.3 x 10^-1             |4.24 x 10^-1           |                     |
|C++14      |Submatrix manipulation     |1.22 x 10^-1            |2.91 x 10^-1           |2.33 x 10^-1            |
|C++17      |Submatrix manipulation     |1.23 x 10^-1            |3.03 x 10^-1           |2.28 x 10^-1            |
|C++20      |Submatrix manipulation     |1.35 x 10^-1            |3.36 x 10^-1           |2.44 x 10^-1            |
|C++23      |Submatrix manipulation     |1.36 x 10^-1            |3.68 x 10^-1           |2.61 x 10^-1            |

These benchmarks indicate that it is indistinct to use cpp11, cpp4r, or Rcpp for Armadillo-based linear algebra
operations, as the differences in speed are minimal. However, cpp4r has some convenient features that may make it more
appealing for certain projects, including C++-side roxygen support that prevents the need for separate R wrapper
functions as with the other wrappers

The benchmark functions for cpp4r are as follows (this is identical for cpp11 and Rcpp):

```
/* roxygen
@title Multiply Four Matrices
@export
*/
[[cpp4r::register]] doubles_matrix<> multiply_four_cpp4r(const doubles_matrix<>& a, const doubles_matrix<>& b,
  const doubles_matrix<>& c, const doubles_matrix<>& d) {
  mat A = as_mat(a);
  mat B = as_mat(b);
  mat C = as_mat(c);
  mat D = as_mat(d);

  uword n = A.n_cols;
  uword n5 = n / 5;
  uword n10 = n / 10;

  // Break the chained multiply into a sequence that reuses temporaries
  // and lets BLAS operate on larger contiguous blocks where possible.
  mat T1 = B.cols(0, n5 - 1); // view (no copy)
  mat T2 = C.submat(0, 0, n5 - 1, n10 - 1); // view

  // Compute intermediate as A * T1 into a temporary (uses BLAS)
  mat I = A * T1; // one allocation for I

  // Then I * T2 -> J
  mat J = I * T2; // one allocation for J

  // Finally multiply by D.submat(...) and return
  mat Z = J * D.submat(0, 0, n10 - 1, n10 - 1);
  return as_doubles_matrix(Z);
}

/* roxygen
@title Submatrix Manipulation
@export
*/
[[cpp4r::register]] doubles_matrix<> submatrix_manipulation_cpp4r(const doubles_matrix<>& a, const doubles_matrix<>& b) {
  mat A = as_mat(a);
  mat B = as_mat(b);
  mat Z = B;
  Z.row(Z.n_rows - 1) = A.row(0);
  return as_doubles_matrix(Z);
}

/* roxygen
@title Multi-Operation Expression
@export
*/
[[cpp4r::register]] double multi_operation_cpp4r(const doubles_matrix<>& a, const doubles_matrix<>& b,
  const doubles_matrix<>& c) {
  mat A = as_mat(a);
  mat B = as_mat(b);
  mat C = as_mat(c);

  double Z = as_scalar(A.col(0).t() * inv(diagmat(diagvec(B))) * C.col(0));

  return Z;
}
```

# Impact

By providing a portable interface for C++ integration, cpp4r enables R developers to leverage the power of modern C++
while minimizing the complexity typically associated with writing compiled code. The benchmarks demonstrate substantial
speed and memory usage improvements compared to existing implementations, providing researchers with a useful tool to
write R packages to analyze large datasets and intensive computations.

Beyond improved memory usage, which can determine whether an analysis is feasible, cpp4r's design
also offers faster compilation times, enhancing development workflow and testing. This is
particularly beneficial in academic and business settings, where prototyping and iteration are common before final
implementation.

cpp4r represents an evolution in C++ bindings for R, building upon the solid foundation established by cpp11 while
addressing specific limitations and adding features that can benefit the R community. By maintaining API compatibility
with cpp11, cpp4r provides a migration path for developers seeking enhanced functionality without requiring significant
code restructuring.

# Conclusion

The development of cpp4r demonstrates the value of open-source transparency and how it enables derived works. While
cpp11 and Rcpp continue to serve the broader R community effectively, cpp4r offers an alternative for projects
requiring its specific enhancements, particularly in academic research contexts where documentation features and
additional data types support reduce the coding effort for advancing computational methods.

The software, documentation, and replication code are available on [GitHub](https://github.com/pachadotdev/cpp4r). The
codebase is released under the Apache 2.0 license. Contributions and feedback from the R community are welcome to
help improve the package further. We hope that cpp4r will be a valuable tool for R developers, providing a
simple solution for performance bottlenecks by integrating C++ code into R packages.

# References
