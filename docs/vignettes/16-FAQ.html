<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>17 - FAQs ‚Ä¢ cpp4r</title><link rel="stylesheet" href="../menu.css"><link rel="stylesheet" href="../content.css"><!-- MathJax Configuration --><script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']],
        processEscapes: true,
        processEnvironments: true,
        packages: {'[+]': ['ams', 'newcommand', 'configmacros']}
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
  </script><script id="MathJax-script" async src="../js/tex-svg.js"></script></head><body>
<div class="main-container">
<div id="menu">
  <div>
    <img src="../man/figures/logo.svg" align="center" height="139" alt="cpp4r logo"></div>

  <div class="search-container">
    <input type="text" id="search-box" placeholder="Search..."></div>

  <div class="search-container">
    <button id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">Toggle theme</button>
    <button id="font-decrease" title="Decrease font size" aria-label="Decrease font size">A-</button>
    <button id="font-increase" title="Increase font size" aria-label="Increase font size">A+</button>
  </div>

  <div class="submenu">
    <label style="border-bottom: 0;"><a style="padding-left: 0;" href="../index.html">Home üè†</a></label>
  </div>

  <div class="submenu">
    <label>Functions</label>
    <a href="../reference/register.html">register</a>
    <a href="../reference/pkg_template.html">pkg_template</a>
    <a href="../reference/unvendor.html">unvendor</a>
    <a href="../reference/vendor.html">vendor</a>
  </div>

  <div class="submenu">
    <label>Vignettes</label>
    <a href="../vignettes/01-motivations.html">01 - Motivations for cpp4r</a>
    <a href="../vignettes/02-setup.html">02 - Setup</a>
    <a href="../vignettes/03-package-skeleton.html">03 - Package Skeleton</a>
    <a href="../vignettes/04-read-only.html">04 - Read-only versus Writable R Objects</a>
    <a href="../vignettes/05-logical-functions.html">05 - Logical Functions</a>
    <a href="../vignettes/06-rolling-functions.html">06 - Rolling Functions</a>
    <a href="../vignettes/07-statistical-functions.html">07 - Statistical Functions</a>
    <a href="../vignettes/08-logical-functions-2.html">08 - Logical Functions with Missing Values</a>
    <a href="../vignettes/09-rolling-functions-2.html">09 - Rolling Functions with Missing Values</a>
    <a href="../vignettes/10-statistical-functions-2.html">10 - Statistical Functions with Missing Values</a>
    <a href="../vignettes/11-debugging.html">11 - Debugging R Packages</a>
    <a href="../vignettes/12-external-pointers.html">12 - External Pointers</a>
    <a href="../vignettes/13-compiler-optimization.html">13 - Compiler Optimizations</a>
    <a href="../vignettes/14-linear-algebra.html">14 - Linear Algebra</a>
    <a href="../vignettes/15-internals.html">15 - Internals</a>
    <a href="../vignettes/16-FAQ.html">17 - FAQs</a>
    <a href="../vignettes/17-worked-examples.html">16 - Worked Examples</a>
  </div>

  <div class="submenu">
    <label>News</label>
    <a href="../news/index.html">Changelog</a>
  </div>
</div>
<div id="content">
<div class="content-wrapper">
        <div class="content-main">
          <h1>17 - FAQs</h1>
<script src="libs/header-attrs-2.30/header-attrs.js"></script><h1 class="title toc-ignore">17 - FAQs</h1>



<pre class="r"><code>knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#&gt;"
)
library(cpp4r)</code></pre>
<p>Below are some Frequently Asked Questions about cpp4r. If you have a
question that you think would fit well here please <a href="https://github.com/pachadotdev/cpp4r/issues/new/choose">open an
issue</a>.</p>
<div id="is-this-only-compatible-with-c11" class="section level1">
<h1>Is this only compatible with C++11?</h1>
<p>No, cpp4r requires at least C++11. It is compatible with C++14,
C++17, C++20, C++23 as well. The headers are written in a way that is
compatible with all of these standards and newer features are used if
the compiler supports them.</p>
</div>
<div id="can-i-specify-which-c-standard-to-use" class="section level1">
<h1>Can I specify which C++ standard to use?</h1>
<p>Yes, you can specify the C++ standard to use when compiling your
cpp4r code. Some packages like <code>tesseract</code> use a
<code>SystemRequirements</code> field in their <code>DESCRIPTION</code>
file to specify the C++ standard because the underlying Tesseract
library requires it.</p>
<p>CRAN states that <code>SystemRequirements: C++11</code> or any other
C++ standard must be written in the <code>DESCRIPTION</code> file if and
only if it is essential to build the package. Otherwise, it is not
necessary to specify the C++ standard.</p>
</div>
<div id="my-laptop-uses-cnn-but-my-cluster-uses-cmm-how-can-i-make-sure-my-code-works-on-both" class="section level1">
<h1>My laptop uses C++NN but my cluster uses C++MM, how can I make sure
my code works on both?</h1>
<p>The headers were tested to verify that all the unit tests for cpp4r
pass when compiled with C++11, C++14, C++17, C++20, and C++23.</p>
<p>For consistency, which is not required unless you have a dependency
that requires a specific C++ standard, you can write a
<code>DESCRIPTION</code> like this</p>
<pre><code>Package: mypkg
Title: Descriptive Title
Version: 0.1.0
Authors@R:
    person(
        given = "You R.",
        family = "Name",
        role = c("aut", "cre")
    )
Description: Descriptive description.
License: Apache License (&gt;= 2)
Encoding: UTF-8
LinkingTo: cpp4r
SystemRequirements: C++11/14/17/20/23</code></pre>
<p>and in <code>Makevars.in</code> (or Makevars.win) you can write</p>
<pre><code>CXX_STD = CXX11/14/17/20/23</code></pre>
<p>See the compiler optimization vignette for more details on how to set
compiler flags and use anticonf scripts.</p>
</div>
<div id="what-are-the-underlying-types-of-cpp4r-objects" class="section level1">
<h1>What are the underlying types of cpp4r objects?</h1>
<table><thead><tr class="header"><th>vector</th>
<th>element</th>
</tr></thead><tbody><tr class="odd"><td>cpp4r::integers</td>
<td>int</td>
</tr><tr class="even"><td>cpp4r::doubles</td>
<td>double</td>
</tr><tr class="odd"><td>cpp4r::logicals</td>
<td>cpp4r::r_bool</td>
</tr><tr class="even"><td>cpp4r::strings</td>
<td>cpp4r::r_string</td>
</tr><tr class="odd"><td>cpp4r::raws</td>
<td>uint8_t</td>
</tr><tr class="even"><td>cpp4r::list</td>
<td>SEXP</td>
</tr></tbody></table></div>
<div id="how-do-i-add-elements-to-a-list" class="section level1">
<h1>How do I add elements to a list?</h1>
<p>Use the <code>push_back()</code> method. You will need to use
<code>cpp4r::as_sexp()</code> if you want to convert arbitrary C++
objects to <code>SEXP</code> before inserting them into the list.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
#include &lt;vector&gt;

[[cpp4r::register]]
cpp4r::writable::list foo_push() {
  cpp4r::writable::list x;

  // An object that is already a `SEXP`
  x.push_back(R_NilValue);

  // A single integer
  x.push_back(cpp4r::as_sexp(1));

  // A C++ vector of ints
  std::vector&lt;int&gt; elt{1, 2, 3};
  x.push_back(cpp4r::as_sexp(elt));

  return x;
}</code></pre>
<p>To create named lists, use the <code>push_back()</code> method with
the named literal syntax. The named literal syntax is defined in the
<code>cpp4r::literals</code> namespace. In this case, creating the named
literal automatically calls <code>as_sexp()</code> for you.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
cpp4r::writable::list foo_push_named() {
  using namespace cpp4r::literals;

  cpp4r::writable::list x;
  x.push_back({"foo"_nm = 1});

  return x;
}</code></pre>
<p>Note that if you know the size of the list ahead of time (which you
often do!), then it is more efficient to state that up front.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
#include &lt;vector&gt;

[[cpp4r::register]]
cpp4r::writable::list foo_push_sized() {
  std::vector&lt;int&gt; elt{1, 2, 3};

  R_xlen_t size = 3;

  cpp4r::writable::list x(size);
  x[0] = R_NilValue;
  x[1] = cpp4r::as_sexp(1);
  x[2] = cpp4r::as_sexp(elt);

  return x;
}</code></pre>
</div>
<div id="does-cpp4r-support-default-arguments" class="section level1">
<h1>Does cpp4r support default arguments?</h1>
<p>cpp4r does not support default arguments, while convenient they would
require more complexity to support than is currently worthwhile. If you
need default argument support you can use a wrapper function around your
cpp4r registered function. A common convention is to name the internal
function with a trailing <code>_</code>.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
[[cpp4r::register]]
double add_some_(double x, double amount) {
  return x + amount;
}</code></pre>
<pre class="r"><code>add_some &lt;- function(x, amount = 1) {
  add_some_(x, amount)
}
add_some(1)
add_some(1, amount = 5)</code></pre>
</div>
<div id="how-do-i-create-a-new-empty-list" class="section level1">
<h1>How do I create a new empty list?</h1>
<p>Define a new writable list object.</p>
<p><code>cpp4r::writable::list x;</code></p>
</div>
<div id="how-do-i-retrieve-named-elements-from-a-named-vectorlist" class="section level1">
<h1>How do I retrieve (named) elements from a named vector/list?</h1>
<p>Use the <code>[]</code> accessor function.</p>
<p><code>x["foo"]</code></p>
</div>
<div id="how-can-i-tell-whether-a-vector-is-named" class="section level1">
<h1>How can I tell whether a vector is named?</h1>
<p>Use the <code>named()</code> method for vector classes.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
bool is_named(cpp4r::strings x) {
  return x.named();
}</code></pre>
<pre class="r"><code>is_named("foo")

is_named(c(x = "foo"))</code></pre>
</div>
<div id="how-do-i-return-a-cpp4rwritablelogicals-object-with-only-a-false-value" class="section level1">
<h1>How do I return a ‚Äúcpp4r::writable::logicals‚Äù object with only a
‚ÄúFALSE‚Äù value?</h1>
<p>You need to use <a href="https://en.cppreference.com/w/cpp/language/list_initialization.html">list
initialization</a> with <code>{}</code> to create the object.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
cpp4r::writable::logicals my_false() {
  return {FALSE};
}

[[cpp4r::register]]
cpp4r::writable::logicals my_true() {
  return {TRUE};
}

[[cpp4r::register]]
cpp4r::writable::logicals my_both() {
  return {TRUE, FALSE, TRUE};
}</code></pre>
<pre class="r"><code>my_false()

my_true()

my_both()</code></pre>
</div>
<div id="how-do-i-create-a-new-empty-environment" class="section level1">
<h1>How do I create a new empty environment?</h1>
<p>To do this you need to call the <code>base::new.env()</code> function
from C++. This can be done by creating a <code>cpp4r::function</code>
object and then calling it to generate the new environment.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
cpp4r::environment create_environment() {
  cpp4r::function new_env(cpp4r::package("base")["new.env"]);
  return new_env();
}</code></pre>
</div>
<div id="how-do-i-assign-and-retrieve-values-in-an-environment-what-happens-if-i-try-to-get-a-value-that-does-not-exist" class="section level1">
<h1>How do I assign and retrieve values in an environment? What happens
if I try to get a value that does not exist?</h1>
<p>Use <code>[]</code> to retrieve or assign values from an environment
by name. If a value does not exist, it will error. To check for
existence ahead of time, use the <code>exists()</code> method.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
bool foo_exists(cpp4r::environment x) {
  return x.exists("foo");
}

[[cpp4r::register]]
void set_foo(cpp4r::environment x, double value) {
  x["foo"] = value;
}</code></pre>
<pre class="r"><code>x &lt;- new.env()

foo_exists(x)

set_foo(x, 1)

foo_exists(x)</code></pre>
</div>
<div id="how-can-i-create-a-cpp4rraws-from-a-stdstring" class="section level1">
<h1>How can I create a ‚Äúcpp4r:raws‚Äù from a ‚Äústd::string‚Äù?</h1>
<p>There is no built in way to do this. One method would be to
<code>push_back()</code> each element of the string individually.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
cpp4r::raws push_raws() {
  std::string x("hi");
  cpp4r::writable::raws out;

  for (auto c : x) {
    out.push_back(c);
  }

  return out;
}</code></pre>
<pre class="r"><code>push_raws()</code></pre>
</div>
<div id="how-can-i-create-a-stdstring-from-a-cpp4rwritablestring" class="section level1">
<h1>How can I create a ‚Äústd::string‚Äù from a
‚Äúcpp4r::writable::string‚Äù?</h1>
<p>Because C++ does not allow for two implicit cast, explicitly cast to
<code>cpp4r::r_string</code> first.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
#include &lt;string&gt;

[[cpp4r::register]]
std::string my_string() {
  cpp4r::writable::strings x({"foo", "bar"});
  std::string elt = cpp4r::r_string(x[0]);
  return elt;
}</code></pre>
</div>
<div id="what-are-the-types-for-c-iterators" class="section level1">
<h1>What are the types for C++ iterators?</h1>
<p>The iterators are <code>::iterator</code> classes contained inside
the vector classes. For example the iterator for
<code>cpp4r::doubles</code> would be
<code>cpp4r::doubles::iterator</code> and the iterator for
<code>cpp4r::writable::doubles</code> would be
<code>cpp4r::writable::doubles::iterator</code>.</p>
</div>
<div id="whats-wrong-with-using-namespace-std" class="section level1">
<h1>What‚Äôs wrong with ‚Äúusing namespace std‚Äù?</h1>
<p>The <code>using namespace std</code> directive will not be included
in the generated code of the function signatures, and it will not be
included in future releases.</p>
<p>Please do not use <code>using namespace std;</code>. It is considered
bad practice in C++ because it can lead to name conflicts and
ambiguities, especially in larger codebases or when integrating multiple
libraries.</p>
<p>Some interesting discussion on this topic can be found in the
following links:</p>
<ul><li><a href="https://stackoverflow.com/questions/1452721/whats-the-problem-with-using-namespace-std">What‚Äôs
the problem with ‚Äúusing namespace std;‚Äù?</a></li>
<li><a href="https://www.geeksforgeeks.org/cpp/using-namespace-std-considered-bad-practice/">Why
‚Äúusing namespace std‚Äù is considered bad practice</a></li>
<li><a href="https://medium.com/@pradeepbehara/why-you-should-avoid-using-namespace-std-in-c-best-practices-for-clean-and-maintainable-code-e9ab77518be4">Why
You Should Avoid Using namespace std in C++: Best Practices for Clean
and Maintainable Code</a></li>
</ul><p>Even when this will work:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
#include &lt;string&gt;

using namespace std;

[[cpp4r::register]] std::string foobar() {
  return string("foo") + "-bar";
}</code></pre>
<p>Please please please do this instead:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;
#include &lt;string&gt;

[[cpp4r::register]]
std::string foobar() {
  return std::string("foo") + "-bar";
}</code></pre>
</div>
<div id="how-do-i-modify-a-vector-in-place" class="section level1">
<h1>How do I modify a vector in place?</h1>
<p>In place modification breaks the normal semantics of R code. In
general it should be avoided, which is why <code>cpp4r::writable</code>
classes always copy their data when constructed.</p>
<p>However, if you are <em>positive</em> in-place modification is
necessary for your use case, you can use the move constructor to do
this.</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
void add_one(cpp4r::sexp x_sexp) {
  cpp4r::writable::integers x(std::move(x_sexp.data()));
  for (auto&amp;&amp; value : x) {
    ++value;
  }
}</code></pre>
<pre class="r"><code>x &lt;- c(1L, 2L, 3L, 4L)
.Internal(inspect(x))
add_one(x)
.Internal(inspect(x))
x</code></pre>
</div>
<div id="should-i-call-unwind_protect-manually" class="section level1">
<h1>Should I call ‚Äúunwind_protect‚Äù manually?</h1>
<p><code>cpp4r::unwind_protect()</code> is cpp4r‚Äôs way of safely calling
R‚Äôs C API. In short, it allows you to run a function that might throw an
R error, catch the <code>longjmp()</code> of that error, promote it to
an exception that is thrown and caught by a try/catch that cpp4r sets up
for you at <code>.Call()</code> time (which allows destructors to run),
and finally tells R to continue unwinding the stack now that the C++
objects have had a chance to destruct as needed.</p>
<p>Since <code>cpp4r::unwind_protect()</code> takes an arbitrary
function, you may be wondering if you should use it for your own custom
needs. In general, this is advised against because this is an extremely
advanced feature that is prone to subtle and hard to debug issues.</p>
<div id="destructors" class="section level2">
<h2>Destructors</h2>
<p>The following setup for <code>test_destructor_ok()</code> with a
manual call to <code>unwind_protect()</code> would work:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

class A {
 public:
  ~A();
};

A::~A() {
  Rprintf("hi from the destructor!");
}

[[cpp4r::register]]
void test_destructor_ok() {
  A a{};
  cpp4r::unwind_protect([&amp;] {
    Rf_error("oh no!");
  });
}

[[cpp4r::register]]
void test_destructor_bad() {
  cpp4r::unwind_protect([&amp;] {
    A a{};
    Rf_error("oh no!");
  });
}</code></pre>
<pre class="r"><code>test_destructor_ok()</code></pre>
<p>But if you happen to move <code>a</code> into the
<code>unwind_protect()</code>, then it will not be destructed, and you
will end up with a memory leak at best, and a much more sinister issue
if your destructor is important:</p>
<pre class="r"><code>test_destructor_bad()
#&gt; Error: oh no!</code></pre>
<p>In general, the only code that can be called within
<code>unwind_protect()</code> is ‚Äúpure‚Äù C code or C++ code that only
uses POD (plain-old-data) types and no exceptions. If you mix complex
C++ objects with R‚Äôs C API within <code>unwind_protect()</code>, then
any R errors will result in a jump that prevents your destructors from
running.</p>
</div>
<div id="nested-unwind_protect" class="section level2">
<h2>Nested <code>unwind_protect()</code></h2>
<p>Another issue that can arise has to do with <em>nested</em> calls to
<code>unwind_protect()</code>. It is very hard (if not impossible) to
end up with invalidly nested <code>unwind_protect()</code> calls when
using the typical cpp4r API, but you can manually create a scenario like
the following:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
void test_nested() {
  cpp4r::unwind_protect([&amp;] {
    cpp4r::unwind_protect([&amp;] {
      Rf_error("oh no!");
    });
  });
}</code></pre>
<p>If you were to run <code>test_nested()</code> from R, it would likely
crash or hang your R session due to the following chain of events:</p>
<ul><li><code>test_nested()</code> sets up a try/catch to catch unwind
exceptions</li>
<li>The outer <code>unwind_protect()</code> is called. It uses the C
function <code>R_UnwindProtect()</code> to call its lambda
function.</li>
<li>The inner <code>unwind_protect()</code> is called. It again uses
<code>R_UnwindProtect()</code>, this time to call
<code>Rf_error()</code>.</li>
<li><code>Rf_error()</code> performs a <code>longjmp()</code> which is
caught by the inner <code>unwind_protect()</code> and promoted to an
exception.</li>
<li>That exception is thrown, but because the code is in the outer call
to <code>R_UnwindProtect()</code> (a C function), it ends up throwing
that exception <em>across</em> C stack frames. This is <em>undefined
behavior</em>, which is known to have caused R to crash on certain
platforms.</li>
</ul><p>You might think that you‚Äôd never do this, but the same scenario can
also occur with a combination of 1 call to <code>unwind_protect()</code>
combined with usage of the cpp4r API:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
void test_hidden_nested() {
  cpp4r::unwind_protect([&amp;] {
    cpp4r::stop("oh no!");
  });
}</code></pre>
<p>Because <code>cpp4r::stop()</code> (and most of the cpp4r API) uses
<code>unwind_protect()</code> internally, this has indirectly ended up
in a nested <code>unwind_protect()</code> scenario again.</p>
<p>In general, if you must use <code>unwind_protect()</code> then you
must be very careful not to use any of the cpp4r API inside of the
<code>unwind_protect()</code> call.</p>
<p>It is worth pointing out that calling out to an R function from cpp4r
which then calls back into cpp4r is still safe, i.e.¬†if the registered
version of the imaginary <code>test_outer()</code> function below was
called from R, then that would work:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
void test_inner() {
  cpp4r::stop("oh no!")
}

[[cpp4r::register]]
void test_outer() {
  auto fn = cpp4r::package("mypackage")["test_inner"]
  fn();
}</code></pre>
<p>This might seem unsafe because <code>cpp4r::package()</code> uses
<code>unwind_protect()</code> to call the R function for
<code>test_inner()</code>, which then goes back into C++ to call
<code>cpp4r::stop()</code>, which itself uses
<code>unwind_protect()</code>, so it seems like the code is in a nested
scenario, but this scenario does actually work. It makes more sense if
you analyze it one step at a time:</p>
<ul><li>Call the R function for <code>test_outer()</code></li>
<li>A try/catch is set up to catch unwind exceptions</li>
<li>The C++ function for <code>test_outer()</code> is called</li>
<li><code>cpp4r::package()</code> uses <code>unwind_protect()</code> to
call the R function for <code>test_inner()</code></li>
<li>Call the R function for <code>test_inner()</code></li>
<li>A try/catch is set up to catch unwind exceptions (<em>this is the
key!</em>)</li>
<li>The C++ function for <code>test_inner()</code> is called</li>
<li><code>cpp4r::stop("oh no!")</code> is called, which uses
<code>unwind_protect()</code> to call <code>Rf_error()</code>, causing a
<code>longjmp()</code>, which is caught by that
<code>unwind_protect()</code> and promoted to an exception.</li>
<li>That exception is thrown, but this time it is caught by the
try/catch set up by <code>test_inner()</code> as it was entered from the
R side. This prevents that exception from crossing the C++ -&gt; C
boundary.</li>
<li>The try/catch calls <code>R_ContinueUnwind()</code>, which
<code>longjmp()</code>s again, and now the <code>unwind_protect()</code>
set up by <code>cpp4r::package()</code> catches that, and promotes it to
an exception.</li>
<li>That exception is thrown and caught by the try/catch set up by
<code>test_outer()</code>.</li>
<li>The try/catch calls <code>R_ContinueUnwind()</code>, which
<code>longjmp()</code>s again, and at this point the
<code>longjmp()</code> can safely proceed to force an R error.</li>
</ul><p>If you have read the above bullet and still feel like you need to
call <code>unwind_protect()</code>, then you should keep in mind the
following when writing the function to unwind-protect:</p>
<ul><li>You should not create any C++ objects that have destructors.</li>
<li>You should not use any parts of the cpp4r API that may call
<code>unwind_protect()</code>.</li>
<li>You must be very careful not to call <code>unwind_protect()</code>
in a nested manner.</li>
</ul><p>In other words, if you only use plain-old-data types, are careful to
never throw exceptions, and only use R‚Äôs C API, then you can use
<code>unwind_protect()</code>.</p>
<p>One place you may want to do this is when working with long character
vectors. Unfortunately, due to the way cpp4r must protect the individual
CHARSXP objects that make up a character vector, it can currently be
quite slow to use the cpp4r API for this. Consider this example of
extracting out individual elements with <code>x[i]</code> vs using the
native R API:</p>
<pre class="cpp"><code>#include &lt;cpp4r.hpp&gt;

[[cpp4r::register]]
cpp4r::sexp test_extract_cpp4r(cpp4r::strings x) {
  const R_xlen_t size = x.size();

  for (R_xlen_t i = 0; i &lt; size; ++i) {
    (void) x[i];
  }

  return R_NilValue;
}

[[cpp4r::register]]
cpp4r::sexp test_extract_r_api(cpp4r::strings x) {
  const R_xlen_t size = x.size();
  const SEXP data{x};

  cpp4r::unwind_protect([&amp;] {
    for (R_xlen_t i = 0; i &lt; size; ++i) {
      (void) STRING_ELT(data, i);
    }
  });

  return R_NilValue;
}</code></pre>
<pre class="r"><code>set.seed(123)
x &lt;- sample(letters, 1e6, replace = TRUE)

bench::mark(
  test_extract_cpp4r(x),
  test_extract_r_api(x)
)</code></pre>
<p>There are plans to improve on this in the future, but for now this is
one of the only places where it is felt to be reasonable to call
<code>unwind_protect()</code> manually.</p>
</div>
</div>
<div id="how-do-i-modify-a-matrix-rownamescolnames-on-c-side" class="section level1">
<h1>How do I modify a matrix rownames/colnames on C++ side?</h1>
<p>Any of the following options will work (the commented code works with
cpp4r):</p>
<pre class="cpp"><code>[[cpp4r::register]]
cpp4r::doubles_matrix&lt;&gt; copy_mat(cpp4r::doubles_matrix&lt;&gt; x) {
  cpp4r::writable::doubles_matrix&lt;&gt; out = x;

  // SEXP dimnames = x.attr("dimnames");
  // if (dimnames != R_NilValue) {
  //   Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames);
  // }

  out.attr("dimnames") = x.attr("dimnames");

  return out;
}

[[cpp4r::register]]
SEXP copy_mat_as_sexp(cpp4r::doubles_matrix&lt;&gt; x) {
  cpp4r::writable::doubles_matrix&lt;&gt; out = x;

  // SEXP dimnames = x.attr("dimnames");
  // if (dimnames != R_NilValue) {
  //   Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames);
  // }

  out.attr("dimnames") = x.attr("dimnames");

  return out;
}

[[cpp4r::register]]
cpp4r::doubles_matrix&lt;&gt; create_mat() {
  cpp4r::writable::doubles_matrix&lt;&gt; out(2, 2);

  out(0, 0) = 1;
  out(0, 1) = 2;
  out(1, 0) = 3;
  out(1, 1) = 4;

  cpp4r::writable::list dimnames(2);
  dimnames[0] = cpp4r::strings({"a", "b"});
  dimnames[1] = cpp4r::strings({"c", "d"});

  out.attr("dimnames") = dimnames;

  return out;
}

[[cpp4r::register]]
cpp4r::doubles_matrix&lt;&gt; create_mat_no_rownames() {
  cpp4r::writable::doubles_matrix&lt;&gt; out(2, 2);

  out(0, 0) = 1;
  out(0, 1) = 2;
  out(1, 0) = 3;
  out(1, 1) = 4;

  cpp4r::writable::list dimnames(2);
  dimnames[0] = R_NilValue; // No row names
  dimnames[1] = cpp4r::strings({"x1", "x2"});

  out.attr("dimnames") = dimnames;

  return out;
}</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script></div>
        <footer><p id="last-updated">Loading...</p>
</footer><script src="../js/footer.js"></script><script src="../js/theme.js"></script><script src="../js/search.js"></script><script src="../js/fontsize.js"></script></div>
</div>
</div>
</body></html>

