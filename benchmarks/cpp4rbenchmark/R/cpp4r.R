# Generated by cpp4r: do not edit by hand

#' @title Matrix Creation, Transpose and Reshape
#' @description Creates matrix from vector, transposes, reshapes, transposes again.
#'   Tests matrix manipulation overhead.
#' @param v Input vector
#' @param nrow Number of rows
#' @param ncol Number of columns
#' @export
bench_matrix_manip <- function(v, nrow, ncol) {
	storage.mode(v) <- "double"
	nrow <- as.integer(nrow)
	ncol <- as.integer(ncol)
	.Call(`_cpp4rbenchmark_bench_matrix_manip`, v, nrow, ncol)
}

#' @title Matrix Power
#' @description Raises each element of matrix to a power.
#' @param a Input matrix
#' @param exponent Power to raise to
#' @export
bench_matrix_power <- function(a, exponent) {
	storage.mode(a) <- "double"
	exponent <- as.numeric(exponent)
	.Call(`_cpp4rbenchmark_bench_matrix_power`, a, exponent)
}

#' @title Vector Sorting
#' @description Sorts a numeric vector using quicksort.
#' @param x Input vector
#' @export
bench_sort <- function(x) {
	storage.mode(x) <- "double"
	.Call(`_cpp4rbenchmark_bench_sort`, x)
}

#' @title Matrix Cross-Product
#' @description Computes A' * A (crossprod).
#' @param a Input matrix
#' @export
bench_crossprod <- function(a) {
	storage.mode(a) <- "double"
	.Call(`_cpp4rbenchmark_bench_crossprod`, a)
}

#' @title Linear Regression via QR
#' @description Solves linear system using QR decomposition approach.
#'   Simplified version that just does the matrix operations.
#' @param a Design matrix
#' @param b Response vector
#' @export
bench_linear_regression <- function(a, b) {
	storage.mode(a) <- "double"
	storage.mode(b) <- "double"
	.Call(`_cpp4rbenchmark_bench_linear_regression`, a, b)
}

#' @title Determinant Computation
#' @description Computes matrix determinant using LU decomposition approach.
#'   Simplified implementation for benchmarking.
#' @param a Input square matrix
#' @export
bench_determinant <- function(a) {
	storage.mode(a) <- "double"
	.Call(`_cpp4rbenchmark_bench_determinant`, a)
}

#' @title Fibonacci Calculation (Vectorized)
#' @description Computes Fibonacci numbers using Binet's formula for vector of indices.
#' @param indices Vector of Fibonacci indices to compute
#' @export
bench_fibonacci_vector <- function(indices) {
	storage.mode(indices) <- "double"
	.Call(`_cpp4rbenchmark_bench_fibonacci_vector`, indices)
}

#' @title Hilbert Matrix Creation
#' @description Creates Hilbert matrix H[i,j] = 1/(i+j-1).
#' @param n Matrix dimension
#' @export
bench_hilbert_matrix <- function(n) {
	n <- as.integer(n)
	.Call(`_cpp4rbenchmark_bench_hilbert_matrix`, n)
}

#' @title Greatest Common Divisor (Vectorized)
#' @description Computes GCD for pairs of integers using Euclidean algorithm.
#' @param x First vector of integers
#' @param y Second vector of integers
#' @export
bench_gcd_vector <- function(x, y) {
	storage.mode(x) <- "integer"
	storage.mode(y) <- "integer"
	.Call(`_cpp4rbenchmark_bench_gcd_vector`, x, y)
}

#' @title Toeplitz Matrix Creation
#' @description Creates Toeplitz matrix T[i,j] = |i-j| + 1 using nested loops.
#' @param n Matrix dimension
#' @export
bench_toeplitz_matrix <- function(n) {
	n <- as.integer(n)
	.Call(`_cpp4rbenchmark_bench_toeplitz_matrix`, n)
}

#' @title Matrix Trace
#' @description Computes trace (sum of diagonal elements) of a matrix.
#' @param m Input matrix
#' @export
bench_trace <- function(m) {
	storage.mode(m) <- "double"
	.Call(`_cpp4rbenchmark_bench_trace`, m)
}

#' @title Escoufier's Method (RV Coefficient)
#' @description Computes RV coefficient for variable selection.
#'   This is a complex mixed test involving correlation matrices and matrix operations.
#' @param x Input matrix
#' @export
bench_escoufier <- function(x) {
	storage.mode(x) <- "double"
	.Call(`_cpp4rbenchmark_bench_escoufier`, x)
}

#' @title Matrix Multiplication
#' @description Standard matrix multiplication: C = A %*% B.
#'   This tests actual numerical computation, not just object creation.
#'   Uses pre-allocation and cache-friendly column-major access.
#' @param A n x m matrix
#' @param B m x p matrix
#' @export
bench_matrix_multiply <- function(A, B) {
	storage.mode(A) <- "double"
	storage.mode(B) <- "double"
	.Call(`_cpp4rbenchmark_bench_matrix_multiply`, A, B)
}

#' @title Rolling Window Mean
#' @description Computes rolling window mean with specified window size.
#'   Tests sequential access patterns. Pre-allocates result vector.
#' @param x data vector
#' @param w window size
#' @export
bench_rolling_mean <- function(x, w) {
	storage.mode(x) <- "double"
	w <- as.integer(w)
	.Call(`_cpp4rbenchmark_bench_rolling_mean`, x, w)
}

#' @title Data Frame Column Operations
#' @description Computes summary statistics for each numeric column in a data frame.
#'   Tests data frame manipulation and type checking.
#'   Returns a data frame with mean, sd, min, max for each column.
#' @param tbl data frame
#' @export
bench_dataframe_summary <- function(tbl) {
	.Call(`_cpp4rbenchmark_bench_dataframe_summary`, tbl)
}

#' @title String Pattern Matching
#' @description Counts occurrences of a pattern in string vector elements.
#' @param s data vector
#' @param p Pattern to search for
#' @export
bench_string_pattern_count <- function(s, p) {
	s <- as.character(s)
	p <- as.character(p)
	.Call(`_cpp4rbenchmark_bench_string_pattern_count`, s, p)
}

#' @title Grouped Aggregation
#' @description Computes mean by group (like tapply or dplyr::summarize).
#' @param x data vector
#' @param groups Integer vector of group IDs
#' @export
bench_grouped_mean <- function(x, groups) {
	storage.mode(x) <- "double"
	storage.mode(groups) <- "integer"
	.Call(`_cpp4rbenchmark_bench_grouped_mean`, x, groups)
}

#' @title Fibonacci Sequence
#' @description Generates Fibonacci sequence up to n terms.
#'   Tests pure computational performance without R API overhead.
#'   Pre-allocates result vector.
#' @param n number of terms
#' @export
bench_fibonacci <- function(n) {
	n <- as.integer(n)
	.Call(`_cpp4rbenchmark_bench_fibonacci`, n)
}

#' @title NA Handling
#' @description Computes mean excluding NAs, like mean(x, na.rm=TRUE).
#' @param x data vector with NAs
#' @export
bench_mean_na_rm <- function(x) {
	storage.mode(x) <- "double"
	.Call(`_cpp4rbenchmark_bench_mean_na_rm`, x)
}

#' @title Outer Product
#' @description Computes outer product of two vectors: result[i,j] = x[i] * y[j].
#'   Tests proper matrix allocation and filling patterns.
#'   This is a case where you must allocate the full result upfront.
#' @param x 1st data vector
#' @param y 2nd data vector
#' @export
bench_outer_product <- function(x, y) {
	storage.mode(x) <- "double"
	storage.mode(y) <- "double"
	.Call(`_cpp4rbenchmark_bench_outer_product`, x, y)
}

#' @title Pairwise Distance Matrix
#' @description Computes Euclidean distance matrix for a set of points.
#'   Returns symmetric n x n distance matrix.
#' @param x (n x k) matrix
#' @export
bench_pairwise_distances <- function(x) {
	storage.mode(x) <- "double"
	.Call(`_cpp4rbenchmark_bench_pairwise_distances`, x)
}

#' @title Cumulative Operations
#' @description Computes cumulative sum, product, min, and max.
#'   Tests sequential data processing patterns.
#' @param x data vector
#' @export
bench_cumulative_ops <- function(x) {
	storage.mode(x) <- "double"
	.Call(`_cpp4rbenchmark_bench_cumulative_ops`, x)
}

#' @title Bootstrap Resampling
#' @description Generates bootstrap resamples and computes statistic.
#'   Tests random sampling and repeated computation.
#'   Returns vector of bootstrap statistics (mean of each resample).
#' @param x data vector
#' @param n_boot number of bootstrap samples
#' @export
bench_bootstrap_mean <- function(x, n_boot) {
	storage.mode(x) <- "double"
	n_boot <- as.integer(n_boot)
	.Call(`_cpp4rbenchmark_bench_bootstrap_mean`, x, n_boot)
}
